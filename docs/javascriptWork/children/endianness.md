# js中大端数据小端数据的区分
```code
// js中大端数据小端数据的区分(Endianness)

// 这里大端小端的意思是，存储多字节的数据
// 比如创建一个无符号的十六位整型
const buf = new ArrayBuffer(32) // 创建一个32位长度的二进制存储空间
// 现在buf就是一个二进制buffer，长为32字节（256位），预先初始化全部为0。一个buffer本身除了查看它的byteLength属性外，并不真正支持任何其他交互
const arr = Uint16Array(buf)
// arr是在这个256(32 * 8 = 256)位buf上映射的一个16位无符号整型的类型数组，也就是说你得到了16个元素。

// arr的映射是按照浏览器平台的大小端设置进行的

// arr是在这个256位buf上映射的一个16位无符号整型的类型数组，也就是说你得到了16个元素。

/**
 * 下面举一个例子将十进制的数字3085，我们用16位来表，如果只用一个16位的数字容器来存放这个时候不管是大端还是小端都是一样的
 * TIPS:但是在浏览器中最小的存储单元室 字节(1字节=8位的二进制)，所以上面的3085用16位表示就需要两个字节表示，这个时候需要将3085(0000110000001101)
 * 进行分割到两个字节中存储，高位->00001100 低位->00001101 （这里的高低位可以理解为10进制【万千百十个】从左到右以此递减）
 * 当讲数字进行多字节存储的时候，就涉及到
 *    大端存储 -> 高位在内存中的低位 (注意下计算机的内存地址分配，都是由低到高进行分配的 eg 0x00000001 0x00000002 0x00000003)
 *    小端存储 -> 低位再内存中的低位
 * 上面0000110000001101-> 高位->00001100 低位->00001101
 *    大端存储 -> 0000110000001101 转16进制=== 0c0d
 *      数据：00001100    00001101
 *      地址：0x00000001  0x00000002
 *    小端存储 -> 0000110100001100 转16进制=== 0d0c
 *      数据：00001101    00001100
 *      地址：0x00000001  0x00000002
 * 如果两者存储方式和读取方式不一致会导致数据偏差
 * */

// 下面方法可以检测当前浏览器 支持的是大端还是小端
const littleEndian = ((function() {
    var buffer = new ArrayBuffer(2) // 两个长度字节
    new DataView(buffer).setInt16(0, 256, true)
    return new Int16Array(buffer)[0] === 256
})())
// littleEndian -> true  小端
// littleEndian -> false  大端

// 下面一个关于 Uint8Array

const a = new Uint8Array()
a[0] = 10
a[1] = 20
a[2] = 30

const b = a.map((v)=> {
    return v * v
})

console.log(b) // 100 144 132

// 上面的值 20、30 输出明显不对
// Uint8Array的某个元素赋值为大于8位的值,也就是 最大值是 11111111 2的八次方 256 上面的 20 * 20、30*30 明显超出了界限会被折断
// 20 * 20 = 400 110010000 只能存储8位所以 从右到左边只能保存8位 10010000 -> 十进制为 144
// 30 * 30 = 900 1110000100 只能存储8位所以 从右到左边只能保存8位 10000100 -> 十进制为 132

// 正确处理方法
const b1 = Uint16Array.from(a, function(v) {
    return v * v
}) 
console.log(b1) // 100 400 900
```