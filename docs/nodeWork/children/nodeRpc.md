# 使用Node.js开发RPC服务
```text
RPC(Remote Procedure Call) 远程过程调用，是指调用非当前的其他进程或者机器中的方法函数。

   单板机的程序都放在同一个进程里面，不同间的进程相互调用就是”进程间的相互通讯“，随着互联网的出现进程间的隔阂被进一步消除，资源可以通过互联网在更大的
区域之内进行实现调用，这就是RPC
   远程调用和本地调用的实现原理区别很大，但是架构设计的责任就是设计一个机制，让远程调用和本地调用服务一样大，这种机制就是RPC框架

RPC的原理
  RPC首先需要解决的是通信的问题，RPC有两种通讯方式，1、基于http的RPC通讯。2、基于TCP的RPC通讯

  基于HTTP的RPC：与访问网页一样简单，只是返回结果更单一（JSON或XML）。优点在于实现简单、标准化和跨语言，比较适合对外提供OpenAPI的场景；
    缺点是HTTP传输效率较低、短连接开销较大（HTTP 2.0后有很大改进）
  基于TCP的RPC：由于TCP处于协议栈的下层，这种调用能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。
    但是它需要更多地关注底层的复杂细节，跨语言和跨平台难度大，实现的代价更高，比较适合内部系统之间追求极致性能的场景。  


  这里需要注意的是TCP通道，只能传输二进制的数据，必须将数据结构转换为二进制的格式，传递给对方，这个过程叫做序列化。
  对方收集到二进制的数据，将其转换为可读的数据结构，称之为反序列化。

  RPC的通讯协议，分为通讯层协议和应用层面协议：
    通讯协议：一般和业务没有关系，它的责任是将数据打包、安全的、完整的传输给接收者，TB Remoting、HFS、Dubbo都属于通讯层的协议。
    应用层协议：用来约定数据和二进制之间的转换规则，Hessian、ProtoBuf、json

 这两类协议的关注点不同。对于一个RPC框架来说，通信层协议一旦确定就很少变化，
 这要求它具备足够好的通用性和扩展性；而应用层协议理论上可以针对业务自由选择，
 更多关注编码的效率和跨语言等特性。因此，RPC框架的核心是通信层协议的设计，
 换句话说，理解了通信层协议中各个字段的含义，基本上便也理解了RPC的原理。  


 RPC通信协议:
   通常由一个Header、Payload(类似于http的Body)组成，合起来称之为Packet,之所以需要包因为二进制只完成流的传输，并不知道一次数据请求和响应的起始和结束，我们需要预先定义好包结构才能进行解析。

   协议设计类似于把一个数据包按顺序切分成若干个单位长度的“小格子”，然后约定每个“小格子”里存储什么样的信息。一个“小格子”就是1Byte，它是协议设计的最小单位，1Byte等于8Bit，可以描述0～28字节，具体使用多少字节要看实际存储的信息。

   收到一个数据包时应首先确定它是请求还是响应，所以需要用1Byte来标记包的类型，比如：0表示请求，1表示响应。知道包类型后，还需要将请求和对应的响应关联起来，通常的做法是在请求前生成一个“唯一”的ID，置入Header传递给服务器端，服务器端返回的响应里也要包含同样的ID，这个ID用一个Int32类型(4Byte)的自增数字表示

   要实现包的准确切割，需明确包的长度。其中Header的长度通常是固定的，而Payload的长度是变化的，要在Header中留4Byte来记录Payload的长度。确定包长度后，我们就可以切分出一个个独立的包。Payload部分编码规则由应用层协议决定，不同场景采用的协议可能不一样，那么接收端如何知道用什么协议去解码Payload部分呢？所以，在Header里还需要1Byte来标记应用层协议的类型，我们称之为Codec 
```